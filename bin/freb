#!/usr/bin/env python3

"""usage: freb (commits|rebase)

- commits: for all updated files in working directory,
create a fix commit for the user specified previous commit

- rebase: resolve for last 20 commits the best entry point for a rebase
merging fix commits generated by this tool and fixeable commits.
No rebase are started if nothing is found.
If the entry point is not obvious, user will choose it.

Internally, we're using gitpython:
- Docs: http://gitpython.readthedocs.io/en/stable/tutorial.html
- Samples: https://programtalk.com/python-examples-amp/git.Repo/
"""

__author__ = "Pierrick Greze (github: @pgreze)"
__license__ = "LGPL"
__version__ = "1.0"

import sys
import re
import binascii
import collections
import functools
import operator
import typing
try:
    import git
except ImportError:
    exit("Run: pip3 install gitpython")

hex_to_bin = binascii.a2b_hex
bin_to_hex = binascii.b2a_hex

# Commit fixs

def commits(repo):
    # TODO: use create_patch=True and diff.a_blob or diff.diff
    # in order to mimic "add -p" and not "app file"
    diffs = repo.index.diff(None)

    # Reset working space
    repo.index.reset()
    # And commit changes as fix
    for diff in diffs:
        commit_fix(repo, diff)

def commit_fix(repo, diff: git.diff.Diff):
    if diff.new_file or diff.deleted_file:
        # Ignore added/deleted/renamed
        return

    # Consider diff.raw_rename_from and diff.raw_rename_to
    if diff.a_rawpath != diff.b_rawpath:
        # Not happening if we're only considering working tree
        print('>> Ignore update in renamed file %s -> %s' % (
            diff.a_rawpath.decode(),
            diff.b_rawpath.decode(),
        ))
        return

    filepath = diff.a_rawpath.decode()

    # TODO: use diff.a_blob.data_stream.read().decode()
    # With @@ -1,8 +1,9 @@
    # For @@ from-file-range to-file-range @@
    # A file can contains multiple regions, so we could identify multiple parents
    # TODO: use repo.blame(repo.active_branch.commit, filepath)
    # If we're deleting at least 1 line

    # TODO: limit
    # TODO: use repo.iter_commits(paths=filepath)
    lines = repo.git.log('--abbrev-commit', "--format=format:%h %s", filepath).split('\n')
    commit = choose("For %s, choose the fixed commit" % filepath, lines)

    if commit:
        commit_hash, commit_msg = commit[:7], commit[8:]
        repo.index.add([filepath])
        repo.index.commit("Fix %s: %s" % (commit_hash, commit_msg))

def choose(text: str, choices: list):
    print(">> %s (default: 1)" % text)
    for idx, choice in enumerate(choices):
        print("%s -> %s" % (
            (idx + 1) if idx > 0 else "(%s)" % (idx + 1),
            choice))
    try:
        choice = input().strip()
        choice = 0 if not choice else (int(choice) - 1)
        return choices[choice]
    except KeyboardInterrupt:
        return None

# Resolve rebase entry point

def resolve_rebase(repo):
    '''Resolve all fix commits in 20 previous commits and rebase from oldest parent'''
    commit_objects = []
    fixeable_commit_objects = set()
    for commit in repo.iter_commits(max_count=20):
        commit_object = bin_to_hex(commit.binsha).decode()[:7]
        commit_msg = commit.message.split('\n')[0][:50]

        commit_objects.append(commit_object)

        search = re.search('^[F|f]ix ([a-f0-9]{7})', commit_msg)
        if not search:
            continue
        fix_commit_object = search.group(1)
        if not is_valid_commit_object(repo, fix_commit_object):
            continue

        fixeable_commit_objects.add(fix_commit_object)

    if not len(fixeable_commit_objects):
        print('No fix commits found')
        return 0

    # Iterate commits until all commits are found. Last = oldest
    rebase_start = None
    unknown_objects = set()
    for obj in fixeable_commit_objects:
        if obj not in commit_objects:
            unknown_objects.add(obj)
        elif rebase_start is None:
            rebase_start = commit_objects.index(obj)
        else:
            rebase_start = max(rebase_start, commit_objects.index(obj))

    if unknown_objects:
        choices = [] if rebase_start is None else [commit_objects[rebase_start]]
        msg = 'All commits were missing, pick the right one' if not choices else \
            'Some commits were missing, select rebase entry point'
        rebase_start_object = choose(
            msg,
            choices + list(unknown_objects))
    else:
        rebase_start_object = commit_objects[rebase_start]
        try:
            input('Start rebase from %s? Enter to validate' % rebase_start_object)
        except KeyboardInterrupt:
            rebase_start_object = None

    if not rebase_start_object:
        # Abort rebase
        return 0

    # Start interactive rebase with this script as editor
    with repo.git.custom_environment(GIT_EDITOR=sys.argv[0]):
        repo.git.rebase('-i', rebase_start_object)
    return 0

def is_valid_commit_object(repo, obj: str):
    try :
        repo.git.rev_parse('--verify', '%s^{commit}' % obj)
    except git.GitCommandError as e:
        if not 'fatal: Needed a single revision' in e.stderr:
            raise e
        return False
    return True

# Auto rebase

def auto_rebase(rebase_filepath: str):
    '''Edit the prodived rebase file, auto-applying fix commits'''
    commit_objects = set()
    commits = collections.OrderedDict() # object -> message
    fixs = [] # [(fixeable_object, fix_obj, fix_msg)]
    for line in (l.strip() for l in open(rebase_filepath).readlines()):
        if not line or line.startswith('#'):
            continue

        commit = line[5:]
        commit_hash = commit.split(' ')[0]
        commit_msg = commit[len(commit_hash) + 1:]

        commit_objects.add(commit_hash)

        search = re.search('^[F|f]ix ([a-f0-9]+)', commit_msg)
        if not search:
            # Pick this commit
            commits[commit_hash] = commit_msg
            continue

        fix_commit_object = search.group(1)
        if not fix_commit_object in commit_objects:
            # Unknown object (invalid or missing)
            commits[commit_hash] = commit_msg
            continue

        fixs.append((fix_commit_object, commit_hash, commit_msg))

    output = functools.reduce(
        operator.add,
        (['pick %s %s' % (obj, msg)] + flatten_fixs(obj, fixs) for obj, msg in commits.items()),
        [])

    with open(rebase_filepath, mode='w') as f:
        f.writelines([line + '\n' for line in output])

def flatten_fixs(obj: str, fixs: list) -> list:
    '''Resolve recursively all fixs starting from providing commit_obj

    :param obj: commit object
    :param fixs: {object -> [(object, message)]}
    '''
    ret = []
    fixeable_objects = {obj}
    for fixeable_object, fix_obj, fix_msg in fixs:
        if fixeable_object in fixeable_objects:
            ret.append('fixup %s %s' % (fix_obj, fix_msg))
            fixeable_objects.add(fix_obj)
    return ret

if __name__ == '__main__':
    if len(sys.argv) != 2 or sys.argv[1] in ('-h', '--help'):
        print(__doc__[:-1])
        exit(0)
    arg = sys.argv[1]

    if '.git/rebase-merge/git-rebase-todo' in arg:
        auto_rebase(arg)
        exit(0)

    try:
        repo = git.Repo('.')
    except git.InvalidGitRepositoryError:
        exit('Working directory is not a git repository')

    if arg == 'commits':
        commits(repo)
    elif arg == 'rebase':
        exit(resolve_rebase(repo))
